<hr>

학습목표 : out(JspWriter)을 통한 버퍼 ,pageContext(pageContext)를통한 스코프 핸들링


## buffer

버퍼의 용량이 충분하지 않으면 예외가 발생하기 전에 출력이 되버려서 예외처리가 제대로 작동하지 않을수도 있다.

굳이 버퍼의 크기를 바꿔야 하는 이유
페이지 모듈화(하나의 버퍼를 공유함)로 하나의 jsp에 용량이 많아지면 기본 용량(8KB)를 
가뿐히 넘길 수 있기 때문에.

==forward==의 경우에는 다른 jsp로 이동하면서 A에서 만들어진 메모리가 담겨진 버퍼는 지워지고 이동한 B의 메모리가 다시 그 버퍼에 채워진다.
*A에서 B로 이동할때 버퍼에 있던 A의 메모리가 방출되면 forwarding이 불가능해진다.

==include==로 이동하면 A에서 B로 이동하더라도 버퍼에 있던 A의 메모리는 없어지지 않고 B의 메모리와 같이 공유한다.



## pageContext

* 제일 먼저 생성되는 객체
* 나머지 모든 객체들을 가지고있음


```jsp
	기본객체중 가장 먼저 생성되고, 나머지 기본객체에 대한 참조를 가진 객체.
	<%=request==pageContext.getRequest()%>
	<%=session==pageContext.getSession()%>
	<%=request.getContextPath()%> => ${pageContext.request.contextPath}
	
	
	Scope(Map) : 웹 어플리케이션에서 공유 데이터를 저장하기 위한 저장소.
				 생명주기가 다른 4개의 기본객체가 가진 map.
			scope를 통해 공유되는 name/value로 구성된 데이터 : attribute
	1. page scope : pageContext가 관리하는 Map
	2. request scope : request가 관리하는 Map
	3. session scope : session이 관리하는 Map
	4. application scope : ServletContext가 관리하는 Map
	
	setAttribute(name,value), getAttribute(name), removeAttribute(name)
	
	<%
		pageContext.setAttribute("pageAttr", "페이지속성");
		request.setAttribute("requestAttr1", "요청 속성1");
		pageContext.setAttribute("requestAttr2", "요청 속성2", PageContext.REQUEST_SCOPE);
		session.setAttribute("sessionAttr", "세션 속성");
		application.setAttribute("applicationAttr", "어플리케이션 속성");
		
// 		request.getRequestDispatcher("/13/attrView.jsp").include(request, response);
		response.sendRedirect(request.getContextPath()+"/13/attrView.jsp");
	%>
<!-- 	<a href="attrView.jsp">속성 확인</a> -->
```

## Scope















